package PPL_9;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package PPL_3;

import java.io.*;
import java.util.*;

/**
 * <h1>This class simulates the Virtual World in which there exist some girls, boys, couples and a variety of gifts.</h1>
 * <p>Arrays of objects of type Girl, Boy,Gift and Couple are included as instance variables.
 * <p>Class responsibility is to simulate real world activities like match-making and gifting through the member functions.
 * Instance Variables:<br>girl_ob[] : array of Girl objects<br> boy_ob[] : array of Boy objects<br>couple_ob[] : array of Couple objects<br>gift_ob[] : array of Gift objects
 *
 */
public class VirtualWorld {

    Girl[] girl_ob;
    Boy[] boy_ob;
    Gift[] gift_ob;
    Couple[] couple_ob;
    /**
     * Constructor instantiates the instance variables(Arrays of different types of objects) with data generated by Testing Utility.
      * @throws FileNotFoundException if file does not exist
      * @throws IOException  if there is a problem reading a record from the file.
     *
     */
    public VirtualWorld()throws FileNotFoundException, IOException{
        girl_ob=new Girl[12];
        boy_ob=new Boy[58];
        gift_ob = new Gift[150];
        couple_ob=new Couple[12];
        int i=0;
        String line="";
        BufferedReader br1=new BufferedReader(new FileReader("rand_girls.txt"));
        BufferedReader br2=new BufferedReader(new FileReader("rand_boys.txt"));
        BufferedReader br3=new BufferedReader(new FileReader("rand_gifts.txt"));
        while((line=br1.readLine())!=null){
           String []arr=line.split(",");
           if(Integer.parseInt(arr[5])==0){
               girl_ob[i]=new ChoosyGirl(arr[0],Integer.parseInt(arr[1]),Integer.parseInt(arr[2]),Integer.parseInt(arr[3]),Integer.parseInt(arr[4]));

           }

           else if(Integer.parseInt(arr[5])==1)
           {
               girl_ob[i]=new NormalGirl(arr[0],Integer.parseInt(arr[1]),Integer.parseInt(arr[2]),Integer.parseInt(arr[3]),Integer.parseInt(arr[4]));

           }
           else if(Integer.parseInt(arr[5])==2)
           {
               girl_ob[i]=new DesperateGirl(arr[0],Integer.parseInt(arr[1]),Integer.parseInt(arr[2]),Integer.parseInt(arr[3]),Integer.parseInt(arr[4]));

           }
           i++;



       }
        i=0;
       while((line=br2.readLine())!=null){
           String []arr=line.split(",");
           if(Integer.parseInt(arr[5])==0){
               boy_ob[i]=new Miser(arr[0],Integer.parseInt(arr[1]),Integer.parseInt(arr[2]),Integer.parseInt(arr[3]),Integer.parseInt(arr[4]));

           }

           else if(Integer.parseInt(arr[5])==1)
           {
               boy_ob[i]=new Geek(arr[0],Integer.parseInt(arr[1]),Integer.parseInt(arr[2]),Integer.parseInt(arr[3]),Integer.parseInt(arr[4]));

           }
           else if(Integer.parseInt(arr[5])==2)
           {
               boy_ob[i]=new GenerousBoy(arr[0],Integer.parseInt(arr[1]),Integer.parseInt(arr[2]),Integer.parseInt(arr[3]),Integer.parseInt(arr[4]));

           }
           i++;



       }

       for(i=0;i<50;i++){
           line=br3.readLine();
           String []arr=line.split(",");

           gift_ob[i]=new EssentialGift(Integer.parseInt(arr[0]),Integer.parseInt(arr[1]));
       }
        for(;i<100;i++){
           line=br3.readLine();
           String []arr=line.split(",");
           gift_ob[i]=new UtilityGift(Integer.parseInt(arr[0]),Integer.parseInt(arr[1]));
        }
         for(;i<150;i++){
           line=br3.readLine();
           String []arr=line.split(",");
           gift_ob[i]=new LuxuryGift(Integer.parseInt(arr[0]),Integer.parseInt(arr[1]));
         }
         for(i=0; i<couple_ob.length; i++) {
           couple_ob[i]=new Couple();

       }
    }

    /**
     *Method to form couples using generic class BestKSelector.
     *BestKSelector first returns best k valued items( according to primary criterion).
     * Then couple is formed with the best item( according to secondary criterion) from selected best k valued items.
    */
     public void makeMatches(BufferedWriter log, int k) throws IOException{
        Date date=new Date();
        int i,x,y;
        int size=boy_ob.length;
        int intel[]=new int[size],rich[]=new int[size],attr[]=new int[size],girl_attr[]=new int[girl_ob.length],f1[]=new int[girl_ob.length],f2[]=new int[boy_ob.length],f3[]=new int[gift_ob.length];

        int m=0,n=0;
        outer:
        for(i=0;i<girl_ob.length;i++){
           //if(i%2==0){
                while(girl_ob[m].bf!=null){
                    m++;
                    if(m>=girl_ob.length)
                        continue outer;
                }

           BestKSelector<Boy> ob=new BestKSelector<Boy>();
           ArrayList<Boy> a=new ArrayList<Boy>();
           for(int j=0;j<boy_ob.length;j++){

            intel[j]=boy_ob[j].i_level;
            rich[j]=boy_ob[j].budget;
            attr[j]=boy_ob[j].attr;
            if(boy_ob[j].gf==null){
                f2[j]=0;
            }
            else
                f2[j]=1;
        }
            if(girl_ob[m].criteria==0){

                a=ob.getBestK(boy_ob, rich, f2,k);
            }
            else if(girl_ob[m].criteria==1){

                a=ob.getBestK(boy_ob, intel, f2,k);
            }
            else{

                a=ob.getBestK(boy_ob, attr,f2, k);
            }

            Boy bx=null;


           bx=selectMostRich(girl_ob[m],a);
            if(bx==null){                     
                x=selectMostRich(girl_ob[m]);
                bx=boy_ob[x];
            }

            couple_ob[i].getCommitted(girl_ob[m], bx);

            log.write(System.lineSeparator());
            log.write(date.toString()+" "+couple_ob[i].gf.name+" commited to "+couple_ob[i].bf.name+System.lineSeparator());
            m++;
        //}
           /* else{
                 while(boy_ob[n].gf!=null){
                    n++;
                    if(n>=boy_ob.length)
                        continue outer;
                }
                 BestKSelector<Girl> ob=new BestKSelector<Girl>();

                 ArrayList<Girl> a=new ArrayList<Girl>();
                 for(int j=0;j<girl_ob.length;j++){
                     if(girl_ob[j].bf==null){
                        f1[j]=0;
                    }
                    else
                        f1[j]=1;
                    girl_attr[j]=girl_ob[j].attr;
                 }
                 a=ob.getBestK(girl_ob,girl_attr , f1, k);

        Girl gy=null;

                gy=selectBestCostGirl(boy_ob[n],a);

                y=selectBestCostGirl(boy_ob[n]);
                gy=girl_ob[y];

            couple_ob[i].getCommitted(gy, boy_ob[n]);
            log.write(System.lineSeparator());
            log.write(date.toString()+" "+couple_ob[i].gf.name+" commited to "+couple_ob[i].bf.name+System.lineSeparator());
            n++;
            }*/
        }
    }
    /**
     * Method to display the couples formed.
     */
    public void displayMatches(){
        System.out.println("Couples Formed:"+System.lineSeparator());
        for(int i=0;i<couple_ob.length;i++){
            System.out.println(girl_ob[i].name+" "+girl_ob[i].bf+System.lineSeparator());
        }
    }

    public void logCouples(BufferedWriter log) throws IOException{
        Date date=new Date();
        for(int i=0;i<couple_ob.length;i++){

             log.write(System.lineSeparator());
             log.write(date.toString()+" "+couple_ob[i].gf.name+" commited to "+couple_ob[i].bf.name+System.lineSeparator());
         }
    }
    int selectMostRich(Girl g){
        int i,max=0,max_b=0;
        for(i=0;i<boy_ob.length;i++){
            if(boy_ob[i].budget>max_b && boy_ob[i].min_attr<=g.attr && boy_ob[i].budget>=g.m_cost && boy_ob[i].gf==null){
                max_b=boy_ob[i].budget;
                max=i;
            }
        }

        return max;
    }
    /**
     * Method to select most suitable Boy object according to secondary criterion.
     * @param g Girl object for which boyfriend is to be chosen.
     * @param boy_ob list of best k valued boys(according to primary criterion)
     * @return most suitable Boy object according to secondary criterion is returned.
     */
    Boy selectMostRich(Girl g,ArrayList<Boy> boy_ob){
        int i,max=0,max_b=0;
        Boy x=null;
        Iterator itr=boy_ob.iterator();
        while(itr.hasNext()){
            Boy  ob=(Boy)itr.next();
            if(ob.budget>max_b && ob.min_attr<=g.attr && ob.budget>=g.m_cost && ob.gf==null){
                max_b=ob.budget;

                x=ob;
            }
        }
        return x;

        }


        int selectMostAttr(Girl g){
        int i,max=0,max_a=-1;
        for(i=0;i<boy_ob.length;i++){
            if(boy_ob[i].attr>max_a && boy_ob[i].min_attr<=g.attr && boy_ob[i].budget>=g.m_cost && boy_ob[i].gf==null){
                max_a=boy_ob[i].attr;
                max=i;
            }
        }

        return max;
        }
        int selectMostIntel(Girl g){
        int i,max=0,max_i=-1;
        for(i=0;i<boy_ob.length;i++){
            if(boy_ob[i].i_level>max_i && boy_ob[i].min_attr<=g.attr && boy_ob[i].budget>=g.m_cost && boy_ob[i].gf==null){
                max_i=boy_ob[i].i_level;
                max=i;
            }
        }

        return max;
        }
        /**
     * Method to select most suitable Girl object according to secondary criterion(maintenance cost).
     * @param b Boy object for which girlfriend is to be chosen.
     * @param girl_ob list of best k valued girls(according to primary criterion)
     * @return most suitable Girl object according to secondary criterion is returned.
     */
        Girl selectBestCostGirl(Boy b,ArrayList<Girl> girl_ob){
            int i,max=0,max_a=999999999;
            Girl x=null;
        Iterator itr=girl_ob.iterator();
        while(itr.hasNext()){
            Girl  ob=(Girl)itr.next();
           // System.out.println(ob.m_cost);
            if(ob.m_cost<max_a && b.min_attr<=ob.attr && b.budget>=ob.m_cost && ob.bf==null){
                System.out.println(ob.m_cost);
                max_a=ob.m_cost;
                x=ob;
            }
        }
        return x;
    }
        int selectBestCostGirl(Boy b){
            int i,max=0,max_a=999999999;
        for(i=0;i<girl_ob.length;i++){
            if(girl_ob[i].m_cost<max_a && b.min_attr<=girl_ob[i].attr && b.budget>=girl_ob[i].m_cost && girl_ob[i].bf==null){
                max_a=girl_ob[i].m_cost;
                max=i;
            }

        }
        return max;
    }
    void sortGiftsByPrice(){
        // sortGifts diff for diff boys??
        int i,j;
        for(i=1;i<150;i++){
            for(j=0;j<150-i;j++)
                if(gift_ob[j].getPrice()>gift_ob[j+1].getPrice()){
                    Gift ob=gift_ob[j];
                    gift_ob[j]=gift_ob[j+1];
                    gift_ob[j+1]=ob;
                }
                else if(gift_ob[j].getPrice()==gift_ob[j+1].getPrice() && gift_ob[j].getVal()>gift_ob[j+1].getVal()){
                    Gift ob=gift_ob[j];
                    gift_ob[j]=gift_ob[j+1];
                    gift_ob[j+1]=ob;
                }
        }

    }
    /**
     * Method that simulates gift exchanges between couples and logs them in text file "log.txt"
     * according to problem statement using generic class BestKSelector.
     *BestKSelector returns best k valued items
     * Each gift basket is set according to the type of boy: 0-"miser" 1-"geek" 2-"generous".
     * miser always gives cheapest priced gift available till maintenance cost of girl is satisfied
     * geek gives gifts starting from till maintenance cost of girl is satisfied plus one luxury gift if budget allows
     * generous give max cost gifts within their budget
     * @param log a BufferedWriter
     * @param k value of "k"
     * @throws IOException  if there is an error while reading/writing file
     */
        public void performGifting(BufferedWriter log,int k) throws IOException{
            int price[]=new int[gift_ob.length],f[]=new int[gift_ob.length];

            for(int i=0;i<gift_ob.length;i++){
         //  gift_ob[i].gifted=false;
            f[i]=0;
            price[i]=gift_ob[i].getPrice();
            }
            ArrayList<Gift> a=new ArrayList<Gift>();
            BestKSelector<Gift> ob=new BestKSelector<Gift>();
            a=ob.getBestK(gift_ob, price,f, k);


            System.out.println("GIFTING DETAILS:"+System.lineSeparator());
            for (Couple couple_ob1 : couple_ob) {
                /*for(int i=0;i<gift_ob.length;i++){
                     gift_ob[i].gifted=false;
                }*/

                log.write(System.lineSeparator());
                System.out.println();
                couple_ob1.bf.selectGifts(couple_ob1.gf,gift_ob,log);
                System.out.println("Total cost of gifts = "+couple_ob1.bf.money_spent);
                log.write("Total cost of gifts = "+couple_ob1.bf.money_spent+System.lineSeparator());
            }
        }
        /**
         * Method to get the happiness and compatibility of each couple.
         * @param k variable defined in problem statement
         */
        public void getCoupleStats(int k){
            Stats s=new Stats();
            for(int i=0;i<couple_ob.length;i++){
                couple_ob[i].gf.calcHappiness(couple_ob[i].bf.money_spent); //remove n call in couple calc happiness
                couple_ob[i].bf.calcHappiness(couple_ob[i].gf);             //remove n call in couple calc happiness
                couple_ob[i].calcHappiness();
                couple_ob[i].calcCompatibility();

            }
            s.sortCouplesByHappiness(couple_ob);
                    s.printKHappiest(couple_ob,k );
            System.out.println();
            s.sortCouplesByCompatibility(couple_ob);
            s.printKCompatible(couple_ob, k);
        }



    }

